#!/bin/bash

# CALL SUBSHELL
_subshell() {
	echo -e "\e[33mCalling bash subshell\e[0m"
	sleep 2
	echo 'echo -e "\e[33mInside Subshell\e[0m"' >> /root/.bashrc
	echo 'echo -e "\e[33mExit to return back to parent\e[0m"' >> /root/.bashrc
	(clear; exec /bin/bash;)
	sed -i "/Inside Subshell/d" "/root/.bashrc"
	sed -i "/Exit to return back to parent/d" "/root/.bashrc"
	echo -e "\e[33mYou are back to parent\e[0m"
}

parameters_check() {
	if [[ -z "$(echo "$@" | grep '\--fetch-new')" && -z "$(echo "$@" | grep '\-fn')" ]]; then
		if [[ -z "$(echo "$@" | grep '\--base')" && -z "$(echo "$@" | grep '\-b')" ]]; then
			_e_report_back "You must choose a base if your run gse without main menu. Aborting..."
			_e_report_back "See man 1 gse for base options."
			die "Aborting actions..."
		fi
	fi

	if [[ -n $(echo "$@" | grep '\--force-new') ]] && [[ -n $(echo "$@" | grep '\--lawful-good') || -n $(echo "$@" | grep '\-lg') ]]; then
		die "Warning: --force-new suppresses --lawful-good"
		sleep 2
	fi

	if [[ -n $(echo "$@" | grep '\--force-new') && -n $(echo "$@" | grep '\--enforce') ]]; then
		_e_report_back "Warning: --force-new implies --enforce=*"
		sleep 2
	fi

	if [[ -n "$(echo "$@" | grep '\--quiet')" || -n "$(echo "$@" | grep '\-q')" ]] && [[ -n "$(echo "$@" | grep '\--verbose')" || -n "$(echo "$@" | grep '\-v')" ]]; then
		die "Error: verbose & quiet can not be set at the same time"
	fi

	if [[ -n $(echo "$@" | grep '\--lawful-good') && -n $(echo "$@" | grep '\--enforce') ]]; then
		die "Warning: --lawful-good suppresses --enforce"
	fi

	if [[ -n $(echo "$@" | grep '\--force-new') && -n $(echo "$@" | grep '\--keep') ]]; then
		die "Warning: --force-new suppresses --keep. This combination is know to give unexpected results."
	fi

	if [[ -n $(echo "$@" | grep '\--health-check') && "$#" != 1 ]]; then
		die "Warning: --health-check unknown parameters ${@:2}"
	fi

	if [[ -n $(echo "$@" | grep '\--replace-new') && "$#" != 1 ]]; then
		die "Warning: --replace-new: unknown parameters ${@:2}"
	fi

	if [[ -n $(echo "$@" | grep '\--build-minimal') &&  -n $(echo "$" | grep '\--enforce' | grep 'gkernel') ]]; then
		_e_report_back "Warning: --build-minimal suppresses kernel build {gkernel}"
		sleep 2
	fi

	if [[ -n $(echo "$@" | grep '\--build-minimal') &&  -n $(echo "$@" | grep '\--enforce' | grep 'ginitrd') ]]; then
		_e_report_back "Warning: --build-minimal suppresses initramfs {ginitrd}"
		sleep 2
	fi

	if [[ -n $(echo "$@" | grep '\--build-minimal') &&  -n $(echo "$@" | grep '\--enforce' | grep 'ginst') ]]; then
		_e_report_back "Warning: --build-minimal suppresses custom package installation {ginst}"
		sleep 2
	fi
}

die() {
	echo -e "\e[31m$@\e[0m" 1>&2 ; exit 1
}

burn() {
	inspector "$@"
	
	# If keep flag is on, make a backup, then proceed with purge
	if [[ -n "${_flag_keep}" ]]; then
		if _keep "$(basename "$1")" "$1"; then
			echo -e "\e[31mPurging...\e[0m"
			if [[ -d "$1" ]]; then
				rm -rf "$1"
			else
				rm -f "$1"
			fi
		else
			die "Backup failed"
		fi
	else
		echo -e "\e[31mPurging...\e[0m"
		if [[ -d "$1" ]]; then
			rm -rf "$1"
		else
			rm -f "$1"
		fi
	fi
}

_keep(){
	inspector "$@"
	# Create a date entry directory
	_date_var="$(date '+%y-%m-%d')"
	if [[ ! -e "/var/tmp/gse/${_date_var}" ]]; then
		mkdir -p "/var/tmp/gse/${_date_var}"
	fi

	_e_report_back "The keep flag has been detected."
	_e_report_back "Making backup of, $1 before proceeding with purging"
	tar czvf "/var/tmp/gse/${_date_var}/$1.tar.bz2" "$2" >/dev/null 2>&1 \
	&& return 0 || return 1
}

_e_report_back() {
	echo -e "\e[33m$*\e[0m" 1>&2
}

_o_report_back() {
	echo -e "\e[34m$*\e[0m" 1>&2	
}

inspector() {
	[[ -z "$@" ]] && print_inf_f
}

pass() {
	echo -e "[\e[34mDone\e[0m]"
}

print_inf_f() {
	clear
	echo -e "[\e[31mFATAL\e[0m]"
	echo -e "\e[31mIf this message is printed while using the Maim Menu\e[0m"
	echo -e "\e[31mThat means essential files are altered or something bad is happening.\e[0m"
	echo
	echo -e "\e[31mPlease run a health-check from the ~Main Menu~ and a Version check first.\e[0m"
	echo -e "\e[31mIf you see this again after the health/version check, please submit a bug report\e[0m"
	echo -e "\e[31mand stop using the program, or data loss may occur.\e[0m"
	echo
	echo -e "\e[31mExiting...\e[0m"
	exit 1
}

repeat_parta() {
	while true; do
		echo -e "\e[33mPart $1: Has been completed\e[0m"
		echo "Run again? Y/N: "
		read -rp "Input :: <= " YN
		case "${YN}" in
			[yN])
				return 0;;
			[nN])
				return 1;;
		esac
	done
}

help_f() {
	echo "Gentoo Stateless Environment, version: ${GSEVER}"
	echo "Distributed under the GNU General Public License, V2"
	echo "usage: gse [OPTIONS] / "
	echo
	echo "-fe, 	--fetch-new"
	echo "-fcn,	--force-new"
	echo "-lg,	--lawful-good"
	echo "-ef, 	--enforce=x"
	echo "-h, 	--help"
	echo "-k, 	--keep"
	echo "-hc, 	--health-check"
	echo "-rpn,	--replace-new"
	echo "-nk, 	--no-kernel"
	echo "-ni, 	--no-initramfs"
	echo "-bc, 	--build-controller"
	echo "-bm, 	--build-minimal"
	echo
}

_callying_catalyst(){
	inspector "$@"
	echo -e "\e[34mCalling catalyst\e[0m"
	source "${CWORKDIR}/scripts/functions/init_stage3_seq" "$@" \
	|| return 1
}

_extracting_catalyst() {
	CATDIR=$(grep storedir "${CCONFDIR}/system/catalyst/catalyst.conf" \
	| sed '/^#/ d' | awk -F '=' '{ print $2 }' | sed  -e "s_\"__g") \
	&& SNAPSHOTNAME="$(grep 'snapshot:' "${CCONFDIR}/system/catalyst/stage1.spec" \
	| sed '/^#/ d' | sed '/^\s*$/d' | awk -F ' ' '{ print $2 }' | sed  -e "s_\"__g")" \
	&& TARGETPATH="$(grep 'source_subpath' "${CCONFDIR}/system/catalyst/stage3.spec" \
	| sed '/^#/ d' | awk -F ' ' '{ print $2 }' | sed  -e "s_\"__g" | awk -F '/' '{ print $1 }')" \
	&& TARGETSTAMP="$(grep 'version_stamp' "${CCONFDIR}/system/catalyst/stage3.spec" \
	| sed '/^#/ d' | awk -F ' ' '{ print $2 }' | sed  -e "s_\"__g")" \
	&& _workdir_check "${CATDIR}/builds/${TARGETPATH}/stage3-${ARCH}-${TARGETSTAMP}.tar.bz2" \
	"${CDISTDIR}/workdir-catalyst" \
	"${CATDIR}/snapshots/portage-${SNAPSHOTNAME}.tar.bz2" "$@" \
	|| return 1
}

_repeat_subpart() {
	while true; do
		echo -e "\e[33m$1: Has been $2\e[0m"
		echo "Run again? Y/N: "
		read -rp "Input :: <= " YN
		case "${YN}" in
			[yN])
				return 0;;
			[nN])
				return 1;;
			esac
	done
}

_clean_target() {
	inspector "$@"
	[[ -z "$(echo "$@" | grep 'workdir')" ]] && print_inf_f
	
	burn "$1/var/log"
	burn "$1/var/tmp"
	burn "$1/LAST_FAILED_COMMAND"
	burn "$1/LAST_ACTION"
	burn "$1/issues.info"
	burn "$1/root/.bash*"
	burn "$1/usr/src/linux*"
	burn "$1/usr/src/linux"
	burn "$1/sinit.d"
	# MINIMAL SYSTEM REQUEST
	if [[ -n "${_flag_minimal}" ]]; then
		burn "$1/usr/portage"
		burn "$1/var/cache"
		burn "$1/var/db"
		burn "$1/root/.cache"
		burn "$1/usr/local/portage"
		mv "$1/root/.ssh" "$1/"
		burn "$1/root"
		mkdir -p "$1/root"
		mv "$1/.ssh" "$1/root/.ssh"	
	fi
}

sinit_flow_monitor() {
	# PROCESS FLOW TWEAKER DURING ALL BUT CHROOT STAGE. DO NOT EDIT THIS FILE!
	case "$1" in
		EXTRACTION)
			sed -i -e 's/EXTRACTION=0/EXTRACTION=1/g' "${CLOCALLG}/sinprog";;
		RESET)
			sed -i -e 's/1/0/g' "${CLOCALLG}/sinprog";;
		SEED)
			sed -i -e 's/SEED=0/SEED=1/g' "${CLOCALLG}/sinprog"
			sed -i -e 's/CHECK=0/CHECK=1/g' "${CLOCALLG}/sinprog";;
		PARTA)
			sed -i -e 's/PARTA=0/PARTA=1/g' "${CLOCALLG}/sinprog";;
		PARTB)
			sed -i -e 's/PARTB=0/PARTA=1/g' "${CLOCALLG}/sinprog";;
		CATALYST)
			sed -i -e 's/CATALYST=0/CATALYST=1/g' "${CLOCALLG}/sinprog";;
		PRECOMP)
			sed -i -e 's/PRECOMP=0/PRECOMP=1/g' "${CLOCALLG}/sinprog";;
		RDEP)
			sed -i -e 's/RDEP=0/RDEP=1/g' "${CLOCALLG}/sinprog";;
		dn)
			;;
	esac
}

# RDEP CHECK
_dependencies_check() {
	if [[ "${CREL}" == "Gentoo" ]]; then
		echo -e "\e[33mHost system:\e[0m \e[35m${CREL}\e[0m"
		echo -e "\e[33mBefore you begin, it is strongly recommended to make a\e[0m \e[35mruntime dependency\e[0m \e[33mcheck on the host machine\e[0m"
		echo -e "\e[33mThis check is a simple\e[0m \e[35meix\e[0m \e[33m--installed foo check, which will be very fast and also verify\e[0m"
		echo -e "\e[33mthat during the process, nothing unexpected will occur\e[0m"
		echo -e "\e[33mIf\e[0m \e[35meix\e[0m \e[33mis not installed, do no worry, it will get installed\e[0m"
		echo
		while true; do
			echo -e "\e[33mCheck dependencies? Y/N: \e[0m"
			read -rp "Input :: <= " YN
			case "${YN}" in
				[yY])
					echo -e "\e[34mChecking for dependencies\e[0m"
					_lcreq 1 || die
					break;;
				[nN])
					_e_report_back "If you have not run a dependency check before, please abort"
					break;;
			esac
		done
		unset YN
	else
		echo -e "\e[33mHost system:\e[0m \e[33m${CREL}\e[0m"
		echo -e "\e[33mBefore you begin, it is strongly recommended to make a\e[0m \e[35mruntime dependency\e[0m \e[33mcheck on the host machine\e[0m"
		echo -e "\e[33mIf the all runtime dependencies are located, the process will continue, otherwise this window will exit. and expect you to manually install them\e[0m"
		echo -e "\e[33mSince only Gentoo is officially upported, it is expected to manually install any missing dependencies\e[0m"
		while true; do
			echo "Check dependencies? Y/N: "
			read -rp "Input :: <= " YN
			case "${YN:-n}" in
				[yY])
					echo -e "\e[34mChecking for dependencies\e[0m"
					_lcreq 2 die
					break;;
				[nN])
					echo "If you have not run a dependency check before, please abort"
					for i in {1..5}; do
   						sleep 1
   						printf "\r $i"
					done
					break;;
			esac
		done
	fi
unset YN
}

_pseudo_check_purge(){
	[[ -n "$(grep "dist.d/workdir-" "/proc/mounts" | awk -F ' ' '{ print $2 }')" ]] \
	&& while true; do
		while read -r i; do
			umount -l "$i"/* >/dev/null 2>&1 >/dev/null 2>&1
			umount -l "$i" >/dev/null 2>&1 >/dev/null 2>&1
		done < <(grep 'dist.d/workdir-' "/proc/mounts" | awk -F ' ' '{ print $2 }')
		
		[[ -z $(grep "dist.d/workdir-" "/proc/mounts" | awk -F ' ' '{ print $2 }') ]] \
		&& break
	done

	if [[ -n "$@" && -z "$(cat /proc/mounts | grep "workdir-$2")" ]]; then
		if [[ -e "$1" ]]; then
			echo -e "\e[34mMarking workdir for purge\e[0m"
			burn "$1"
		fi
	else
		print_inf_f
	fi
}

_start_again() {
	# PROMPT TO CONTINUE OR START ANEW
	if ! echo "$@" | grep -q 'force'; then
		while true; do
			echo -e "\e[33mDo you want to continue from last time?\e[0m"
			echo -e "\e[33mIf you choose\e[0m \e[31mSTART NEW\e[0m\e[33m, workdir will be\e[0m \e[31mpurged\e[0m"
			echo -e "\e[33mAnswer Yes or START NEW: \e[0m"
			read -p "Input :: <= " YN
			echo 
			case "${YN:-n}" in
				[Yy][eE][sS]|[yY])
					break;;
				"START NEW")
					echo -e "\e[33mChecking...\e[0m"
					_pseudo_check_purge "$1" \
					&& sinit_flow_monitor "RESET" && sed -i -e 's/1/0/g' "${CWORKDIR}/scripts/chroot_scripts/chsinprog"; break;;
				* ) echo "Wrong answer";;
			esac
		done
	elif echo "$@" | grep -q 'force'; then
		echo -e "\e[31mForce is active!\e[0m"
		echo -e "\e[34mResetting\e[0m"
		_pseudo_check_purge "$1" \
		&& sinit_flow_monitor "RESET" && sed -i -e 's/1/0/g' "${CWORKDIR}/scripts/chroot_scripts/chsinprog"
	fi
	unset YN
}

_extract_tarball() {
	[[ -z "$@" && -d "$2" ]] && die "Wrong Parameters"
	mkdir -p "$2"

	echo -e "\e[34mExtracting tarball\e[0m"
	if tar xvjpf "$1" -C "$2" --xattrs --numeric-owner >/dev/null 2>&1; then
		echo -e "[\e[32m*\e[0m] Extracted"
		
		if echo "${_flag_base}" | grep -q 'catalyst'; then
			echo -e "\e[34mExtracting portage\e[0m"
			if tar xvjpf "$3" --xattrs --numeric-owner -C "$2/usr/" >/dev/null 2>&1; then
				echo -e "[\e[32m*\e[0m] Extracted"
			else
				die "Extracting portage FAILED"
			fi
		fi
	else
		die "Extracting tarball FAILED"
	fi
}

_workdir_check() {
	[[ -z "$@" && -d "$2" ]] && die "Wrong Parameters"
	if echo "$@" | grep -q 'force'; then
		_e_report_back "This may take some time"
		_e_report_back "Checking..."
		_pseudo_check_purge "$2"
		_extract_tarball "$@"
	else
		if [[ -d "$2" ]]; then
			while true; do
				echo -e "Seems that there already has been done some work at the \e[34mbuilderdir\e[0m"
				echo "You could either continue from where you left, or backup/purge then start anew"
				echo -e "Give one of: \e[32mCONTINUE\e[0m/\e[34mOLD\e[0m/\e[31mPURGE\e[0m "
				read -rp "Input :: <= " ANS
				case $ANS in
					OLD)
						echo "Backing up..."
						mv "$2" "$2.old"
						_extract_tarball "$@"
						break;;
					PURGE)
						_e_report_back "This may take some time"
						_e_report_back "Checking..."
						_pseudo_check_purge "$2"
						_extract_tarball "$@"
						break;;
					CONTINUE)
						break;;
				esac
			done
		else
			_extract_tarball "$@"
		fi
	fi
}

_am_i_root() {
	if [[ "$1" != "0" ]]
	then
		echo -e "\e[31mThis operation requires root privileges\e[0m"
		echo "Returning back..."
		sleep 2
		BACKTO="MM"
		return 1
	fi
	return 0
}

_export_latest() {
	export GENTOOKEY="$(lynx -dump ${SIGNING_KEY} |  grep "(4096-bit RSA)" | head -1 | awk -F '(' '{ print $1}')"
	export "GENTOOKEY"
	export GENTOOLATEST="$DIST/$(wget -q -O- "${DIST}/latest-stage3-$ARCH.txt" | tail -n 1 | awk -F ' ' '{ print $1 }')"
	export STAGE3TB=$(wget -q -O- "${DIST}/latest-stage3-$ARCH.txt" | tail -n 1 | awk -F ' ' '{ print $1 }' | awk -F '/' '{ print $2 }')
	export GENTOOLATESTASC="$DIST/$(wget -q -O- "${DIST}/latest-stage3-$ARCH.txt" | tail -n 1 | awk -F ' ' '{ print $1 }').DIGESTS.asc"
}

_gentoo_key() {
	[[ -z "${GENTOOKEY}" ]] && die "Wrong Parameters" && return 1
	gpg --keyserver hkps.pool.sks-keyservers.net --recv-keys >/dev/null 2>&1 ${GENTOOKEY} \
	&& echo -e "[\e[32m*\e[0m]\e[32m Fetching Key\e[0m" \
	|| { echo -e "[\e[31m*\e[0m]\e[31m Fetching Key\e[0m"; return 1; }
}

_get_latest() {
	inspector "$@"
	[[ -z "${GENTOOLATEST}" || -z "${GENTOOLATESTASC}" ]] && die "Wrong Parameters" && return 1
	mkdir -p "${CDISTDIR}/dists"
	if [[ -n "$(echo "$@" | grep 'fetch_new')" ]]; then
		echo -e "[\e[34m*\e[0m] Marking stage3-${ARCH}-latest.tar.bz2 for purging"
		burn "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2"
		echo -e "[\e[34m*\e[0m] Marking stage3-${ARCH}-latest.tar.bz2.DIGESTS.asc for purging"
		burn "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2.DIGESTS.asc"
		echo -e "[\e[34m*\e[0m] Marking stage3-${ARCH}-latest.tar.bz2.DIGESTS for purging"
		burn "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2.DIGESTS"
		echo -e "[\e[32m*\e[0m] Fetching \e[34m${STAGE3TB}\e[0m"
		wget -c -O "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2" "${GENTOOLATEST}" >/dev/null 2>&1 \
		&& echo "${STAGE3TB}" > "${CDISTDIR}/dists/latest.info" \
		&& pass || die "FAILED"
	else
		echo -e "[\e[32m*\e[0m] Fetching \e[34m${STAGE3TB}\e[0m"
		wget -c -O "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2" "${GENTOOLATEST}" \
		&& echo "${STAGE3TB}" > "${CDISTDIR}/dists/latest.info" \
		&& pass || die "FAILED"
	fi
	wget -c -O "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2.DIGESTS.asc" "${GENTOOLATESTASC}" >/dev/null 2>&1 \
	&& echo -e "[\e[32m*\e[0m] Fetching \e[34m${GENTOOLATEST}\e[0m" \
	|| { echo -e "[\e[31m*\e[0m] \e[31mFAILD\e[0m: Fetching \e[34m${GENTOOLATEST}\e[0m"; exit 1; }

	wget -c -O "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2.DIGESTS" "${GENTOOLATEST}.DIGESTS" >/dev/null 2>&1 \
	&& echo -e "[\e[32m*\e[0m] Fetching \e[34m${GENTOOLATEST}.DIGESTS\e[0m" \
	|| { echo -e "[\e[31m*\e[0m] \e[31mFAILD\e[0m: Fetching $\e[34m${GENTOOLATEST}.DIGESTS\e[0m"; exit 1; }
}

_verify_download() {
	gpg --verify "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2.DIGESTS.asc" >/dev/null 2>&1 \
	&& echo -e "[\e[32m*\e[0m] Verifying \e[35mcryptographic signature\e[0m" \
	|| { echo -e "[\e[31m*\e[0m] \e[31mFAILD\e[0m: Verifying \e[31mcryptographic signature\e[0m"; exit 1; }

	[[ $(grep -A 1 -i sha512 "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2.DIGESTS.asc" | head -n 2 | grep stage3 | awk -F ' ' '{ print $1 }') \
	== $(sha512sum "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2" |  awk -F ' ' '{ print $1 }') ]] \
	&& echo -e "[\e[32m*\e[0m] Verifying \e[35msha512sums\e[0m" \
	|| { echo -e "[\e[31m*\e[0m] \e[31mFAILD\e[0m: Verifying \e[31msha512sums\e[0m"; exit 1; }
}

_call_fetch_new() {
	source "${CWORKDIR}/scripts/functions/catalyst_functions" || { echo -e "\e[32mMissing scripts\e[0m" && exit 1; }
	_fetch_new "$@"
	_get_latest_snapshot "$@"
}

_seed_net() {
	if [[ $(echo "${_flag_network}") == 0 ]]; then
		if [[ "$(awk -F '=' '/SEED/{ print $2 }' < "${CLOCALLG}/sinprog")" == 0 ]] || echo "$@" | grep -q 'force'; then
			_fetch_new "$@" || die "FAILED"
		else
			if [[ -n "$(echo "${_lawful_args[@]}" | grep 'gseed')" ]]; then
				_e_report_back "Fetch: Lawful entry detected, proceeding..."
			else
				if echo "${_enforce_args[@]}" | grep 'gseed'; then
					_e_report_back "Fetch: Enforce entry detected, forcing..."
					_fetch_new "$@" "force" || die "FAILED"
				else
					if _repeat_subpart "Tarball" "fetched"; then
						_fetch_new "$@" || die "FAILED"
					else	
						_e_report_back "Proceeding on next part..."
					fi
				fi
			fi
		fi
	elif [[ ! -e "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2" ]]; then
		die "No local tarball is present. Please enable network connection and try again"
	elif [[ -e "${CDISTDIR}/dists/stage3-${ARCH}-latest.tar.bz2" ]]; then
		_e_report_back "Stage3 tarball located"
		_e_report_back "Calling catalyst"
	fi
}

_call_force_new() {
	while true; do
		echo -e "\e[31mForce new parameter detected\e[0m"
		echo -e "\e[31mThis option will force everything and purge what stands in its way\e[0m"
		echo -e "\e[31mAre you sure? Y/N \e[0m"
		read -rp "Input :: <= " YN
		case "${YN:-n}" in
			[yY])
				if [[ -z $(echo "$@" | grep 'gcat') && -z $(echo "$@" | grep 'catalyst') ]]; then
					source "${CWORKDIR}/scripts/sinit" "$@"
				fi
				break;;
			[nN])
				exit 0;;
			esac
		done
}

_fetch_new() {
	# CHECK FOR THE POSITIONAL PARAMETERS AND BAILOUT IF THEY ARE MISSING
	[[ -z "$@" ]] && die "Wrong parameters"
	if echo "$@" | grep -q 'force'; then
		echo -e "\e[33mSearching for tarball...\e[0m"
		_export_latest
		# GET LATEST STAGE3 TARBALL, .DIGEST && .DIGEST.asc
		local_stage3="$(cat "${CDISTDIR}/dists/latest.info")"
		if [[ "${local_stage3}" == "${STAGE3TB}" ]]; then
			echo -e "[\e[32m*\e[0m] Latest stage3 is already present locally"
		else
			# FETCH THE KEYS FOR THE CRYPTOGRAPHIC AUTHENTICATION
			_gentoo_key
			# GET LATEST STAGE3 TARBALL, .DIGEST && .DIGEST.asc
			_get_latest "$@"
			# VERIFY THE AUTHENTICATION OF THE DOWNLOADED FILES
			_verify_download
		fi
	else
		echo -e "\e[33mSearching for tarball...\e[0m"
		if [[ -n "${_flag_fetch}" || "$1" == 'fetch_new' ]]; then
			_export_latest
			# FETCH THE KEYS FOR THE CRYPTOGRAPHIC AUTHENTICATION
			_gentoo_key
			# GET LATEST STAGE3 TARBALL, .DIGEST && .DIGEST.asc
			_get_latest "$@"
			# VERIFY THE AUTHENTICATION OF THE DOWNLOADED FILES
			_verify_download
		else
			_export_latest
			# GET LATEST STAGE3 TARBALL, .DIGEST && .DIGEST.asc
			local_stage3="$(cat "${CDISTDIR}/dists/latest.info")"
			if [[ "${local_stage3}" == "${STAGE3TB}" ]]; then
				echo -e "[\e[32m*\e[0m] Latest stage3 is already present locally"
			else
				# FETCH THE KEYS FOR THE CRYPTOGRAPHIC AUTHENTICATION
				_gentoo_key
				# GET LATEST STAGE3 TARBALL, .DIGEST && .DIGEST.asc
				_get_latest "$@"
				# VERIFY THE AUTHENTICATION OF THE DOWNLOADED FILES
				_verify_download
			fi
		fi
	fi
}

# KEEP DOING UMOUNT -l UNTIL THERE IS NO DIST.D/WORKDIR ENTRY ON STDOUT
_unmount() {
	k=0
	[[ -n "$(grep "dist.d/workdir-"$2 "/proc/mounts" | awk -F ' ' '{ print $2 }')" ]] \
	&& while true; do
		while read -r i; do
			umount -l "$i"/* >/dev/null 2>&1 >/dev/null 2>&1
			umount -l "$i" >/dev/null 2>&1 >/dev/null 2>&1
		done < <(grep 'dist.d/workdir-' "/proc/mounts" | awk -F ' ' '{ print $2 }')
		
		[[ -z $(grep "dist.d/workdir-"$2 "/proc/mounts" | awk -F ' ' '{ print $2 }') ]] \
		&& break
		[[ "$k" -ge 20 ]] && return 1
		((++k))
	done
	return 0
}

# MOUNT DEV & SYS WITH RBIND THEN RSLAVE ON TARGET BUILDDIR
_mount_dev_sys() {
	inspector "$@"
	mount --rbind /dev "$1/$2" \
	&& mount --make-rslave "$1/$2" \
	&& echo -e "[\e[32m*\e[0m] Mounting $2" \
	|| { echo -e "[\e[31*\e[0m] Mounting $2"; die "Failed"; }
}

# MOUNT PROC ON TARGET BUILDDIR
_mount_proc() {
	inspector "$@" 
	mount -t proc /proc "$1/proc" \
	&& echo -e "[\e[32m*\e[0m] Mounting proc" \
	|| { echo -e "[\e[31m*\e[0m] Mounting proc"; die "Failed"; }
}

# PREPARE THE BUILDERDIR AND INITIATE CHROOT, DIE IF ANYENTRY FAILS
_prepare_chroot() {
	inspector "$@"

	rm -f "$1/etc/resolv.conf"
	cp -L /etc/resolv.conf "$1/etc/" || die "Failed"

	if [[ -n $(echo "$@" | grep 'catalyst') ]]; then
		# CHECK IF PSEUDOS ARE MOUNTED
		if [[ -n $(cat /proc/mounts | grep 'dist.d/workdir-catalyst' | awk -F ' ' '{ print $1 }') ]]; then
			echo -e "\e[31mPseudos possibly mounted at target directory\e[0m"
			echo -e "\e[33mResolving the issue...\e[0m"
			_unmount "catalyst" || die
		fi
		echo -e "\e[34mMounting pseudo\e[0m"
		[[ -z $(grep 'dist.d/workdir-catalyst' /proc/mounts | awk -F ' ' '{ print $1 }') ]] \
		&& _mount_proc "$1" || die
	elif [[ -n $(echo "$@" | grep 'precomp') ]]; then
		if [[ -n $(cat /proc/mounts | grep 'dist.d/workdir-precomp' | awk -F ' ' '{ print $1 }') ]]; then
			echo -e "\e[31mPseudos possibly mounted at target directory\e[0m"
			echo -e "\e[33mResolving the issue...\e[0m"
			_unmount "precomp" || die
		fi
		echo -e "\e[34mMounting pseudo\e[0m"
		[[ -z $(grep 'dist.d/workdir-precomp' /proc/mounts | awk -F ' ' '{ print $1 }') ]] \
		&& _mount_proc "$1" || die
	fi \
	&& _mount_dev_sys "$1" "dev" \
	&& _mount_dev_sys "$1" "sys" \
	|| die "Something went wrong"

	mkdir -p "$1/sinit.d"

	[[ ! -e "$1/sinit.d/chsinprog" ]] && rsync -aAXr "${CWORKDIR}/scripts/chroot_scripts/" "$1/sinit.d/" >/dev/null 2>&1 \
	|| rsync -aAXr --exclude="chsinprog" "${CWORKDIR}/scripts/chroot_scripts/" "$1/sinit.d/" >/dev/null 2>&1 \
	&& rsync -aAXr "${CCONFDIR}/system/portage/" "$1/sinit.d/" >/dev/null 2>&1 \
	&& rsync -aAXr --exclude="portage" "${CCONFDIR}/system/" "$1/sinit.d/" >/dev/null 2>&1 \
	&& echo -e "[\e[32m*\e[0m] Copying \e[34mbuilder's\e[0m files to new system" \
	|| { echo -e "[\e[31m*\e[0m] Copying \e[34mbuilder's\e[0m files to new system"; die "Failed"; }

	# CREATE REPOS.CONF DIRECOTRY & AND COPY REPOS.CONF TO IT
	mkdir -p "$1/etc/portage/repos.conf"
	cp "$1/usr/share/portage/config/repos.conf" "$1/etc/portage/repos.conf/gentoo.conf" || die

	# Set local timezone if set
	if [[ -n $(cat /etc/timezone) ]]; then
		TIMEZONE=$(cat /etc/timezone)
		sed -i -e "s_TMZ_${TIMEZONE}_g" "$1/sinit.d/chinit.conf"
		unset TIMEZONE
	fi

	echo -e "[\e[32m*\e[0m] Copying requested files"
	if [[ -n $(cat ${CCONFDIR}/system/inject_files | sed '/^#/ d' | sed '/^\s*$/d') ]]; then

		while read -r INJFL; do
			f1="$(echo $INJFL | awk -F ' ' '{ print $1 }')"
			f2="${BWORKDIR}/(echo $INJFL | awk -F ' ' '{ print $2 }')"
			echo "Copying $f1 to $f2"
			rsync -aAXPhrv "$f1" "$f2" >/dev/null 2>&1 \
			&& pass || { mapfile -t INJFLERR < <($INJFL | awk -F ' ' '{ print $1 }'); }
		done < <(cat "${CCONFDIR}/system/inject_files" | sed '/^#/ d' | sed '/^\s*$/d')
		unset INJFL

		if [[ -n "${INJFLERR}" ]]; then
			echo "Failed to copy the following packages: "
			echo "${INJFLERR[@]}"
			while true; do
				echo "You can list the failed files again, continue, request terminal or exit"
				echo "Please choose: LIST/CONTINUE/TERMINAL/EXIT"
				read -rp "Input :: <= " INJFLANS
				case "$INJFLANS" in
					LIST)
						clear; echo "${INJFLERR[@]}";;
					CONTINUE)
						while true; do
							echo "Are you sure? Y/N "
							read -p "Input :: <= " YN
							case $YN in
								[yY])
									echo "Proceeding"
									INJFLESC=0
									break;;
								[nN])
									INJFLESC=1
									;;
							esac
						done;;
					TERMINAL)
						_subshell
						INJFLESC=0;;
					EXIT)
						while true; do
							echo "Are you sure? Y/N "
							read -p "Input :: <= " YN
							case $YN in
								[yY])
									echo "Aborting..."
									exit 0;;
								[nN])
									INJFLESC=1
									break;;
							esac
						done;;
				esac
				[[ "$INJFLESC" == 0 ]] && break
			done
		fi
		unset YN
		unset INJFLESC
		unset INJFLANS
		unset INJFLERR
	else
		echo -e "[\e[32m*\e[0m] List empty"
	fi

	echo -e "\e[34mChrooting at new system\e[0m"
	sleep 0.5
	# PASS ALL PP AND INITIATE CHROOT
	chroot "$1" "sinit.d/chroot_init" "$@" || { echo -e "[\e[31m*\e[0m] Chrooting configuration failed"; die; } \
	&& sinit_flow_monitor "PARTB"
}

# THIS SCRIPT IS SOURCED AT THE BEGINING FOR CHECKING THE BUILDER'S RUNTIME DEPENDENCIES
_lcreq() {
	CRDPENDS=''
	_am_i_root_sub() {
		if [[ "$1" == "0" ]]; then
			return 0
		else
			return 1
		fi
	}

	# GENTOO SECTION
	case "$1" in
		1)
			[[ $(command -v eix) ]] \
			|| { echo -e "[\e[33m*\e[0m] \e[35mPlease install eix to proceed!\e[0m" \
			&& { _am_i_root_sub "$UID" && echo -e "[\e[32m*\e[0m] Root privileges found" \
			&& emerge -aq eix && echo -e "[\e[33m*\e[0m] \e[35mUpdating database\e[0m" \
			&& eix-sync -a >/dev/null 2>&1; } \
			|| { echo -e "[\e[31m*\e[0m] Could not get root privileges" \
			&& echo "Please resolve this issue and start again" && exit 1; }; }

			mapfile -t lreq < <(cat "${CLOCALLG}/loc_req" | sed '/^#/ d' | sed '/^\s*$/d')

			for i in "${lreq[@]}"; do
				sleep 0.1
				if eix --installed "$i" >/dev/null 2>&1; then
					echo -e "[\e[32m*\e[0m] Searching for \e[32m$i\e[0m"
				else
					echo -e "[\e[31m*\e[0m] Searching for $i"
					echo -e "[\e[33m*\e[0m] Attempting to resolve the missing dependency"
					_am_i_root $UID && echo -e "[\e[32m*\e[0m] Root privileges found" \
					&& emerge -aq "$i" \
					|| { echo -e "[\e[31m*\e[0m] Could not get root privileges" \
					&& echo "Please resolve this issue and start again" && exit 1; }
				fi
			done;;
		2)
			# NOT SUPPORTED
			mapfile -t lreq < <(cat "${CLOCALLG}/nogloc_req" | sed '/^#/ d' | sed '/^\s*$/d')

			for i in "${lreq[@]}"; do
				sleep 0.1
				if command -v "$i" >/dev/null 2>&1; then
					echo -e "[\e[32m*\e[0m] Searching for \e[32m$i\e[0m"
				else
					echo -e "[\e[31m*\e[0m] Searching for $i"
					CRDPENDS=1
				fi
			done
			[[ "${CRDPENDS}" == 1 ]] && while true; do
			echo -e "\e[33mIf you think some of those dependencies are name missmatch or not important\e[0m"
			echo -e "\e[33mYou can choose to continue at your own ristk\e[0m"
			echo -e "\e[33mContinue? Y/N: "
			read -rp "Input :: <= " ANS
			case "${ANS}" in
				[yY])
					break;;
				[nN])
					echo "Exiting..." && sleep 1 && exit 1;;
			esac
		done
	esac
}

# CREATE ARRAY OF ENABLED ARGUMENTS
_case_args() {
	case "$1" in
		gfund		)
			_on_eargs+=("$1");;
		gseed		)
			_on_eargs+=("$1");;
		gcat		)
			_on_eargs+=("$1");;
		gextr		)
			_on_eargs+=("$1");;
		gprec		)
			_on_eargs+=("$1");;
		gparta		)
			_on_eargs+=("$1");;
		gupdate		)
			_on_eargs+=("$1");;
		gportage	)
			_on_eargs+=("$1");;
		grebuild	)
			_on_eargs+=("$1");;
		gsnap 		)
			_on_eargs+=("$1");;
		gconfigure	)
			_on_eargs+=("$1");;
		ginst		)
			_on_eargs+=("$1");;
		grun		)
			_on_eargs+=("$1");;
		gkernel		)
			_on_eargs+=("$1");;
		ginitrd		)
			_on_eargs+=("$1");;
		gpartb		)
			_on_eargs+=("$1");;
		*			)
			die "Error: $2 unknown argument $1"
	esac
}

# EXPORT ARGUMENTS
_export_args() {
	if [[ -z "$(echo "$1" | grep '=')" ]]; then
		die "Missing arguments for $2"
	else
		_check_args="${1#*=}"
		if [[ "${_check_args}" == '' ]]; then
			die "No arguments were set for $2. Aborting..."
		else
			declare -a _ARGARRAY=("gfund" "gseed" "gcat" "gextr" "gprec" "gparta" \
				"gupdate" "gportage" "grebuild" "gconfigure" "ginst" "grun" "gkernel" "ginitrd" "gpartb")	

			_on_eargs=()
			if [[ $(echo "${_check_args}" | cut -d ',' -f 1) == $(echo "${_check_args}" | cut -d ',' -f 2) ]]; then
				j="$(echo "${_check_args}" | cut -d ',' -f 1)"
				_case_args "$j" "$2"
			else
				for i in {1..14}; do
					if [[ -n "$(echo "${_check_args}" | cut -d ',' -f $i)" ]]; then
						if [[ -n "$(echo "${_ARGARRAY[@]}" | grep "$(echo "${_check_args}" | cut -d ',' -f $i)")" ]]; then
							j="$(echo "${_check_args}" | cut -d ',' -f $i)"
							_case_args "$j" "$2"
						else
							die "Error: $2 unknown argument $(echo "${_check_args}" | cut -d ',' -f $i)"
						fi
					else
						break
					fi
				done
			fi
		export _on_eargs
		
		fi
	fi
	unset _ARGARRAY
}

# FLAGS AND ARGUMENTS
librarium() {
	_e_report_back "================================================"
	_flag_fetch=''
	_flag_force_new=''
	_flag_keep=''
	_flag_health=''
	_flag_replace=''
	_flag_keep=''
	_flag_initrd=''
	_flag_minimal=''
	_flag_controller=''
	_flag_enforce=''
	_flag_lawful=''
	_flag_verbose=''
	_flag_quiet=''
	_flag_test=''
	_flag_silent=''
	_flag_network=''
	_flag_mm=''
	while true; do
		[[ -z "$@" ]] && return 0
		case "$1" in
			--fetch-new|-fn 			)	
				_e_report_back "Fetch new is enabled"
				_flag_fetch=0
				export _flag_fetch;;

			--force-new|-fcn 			)
				_flag_force_new=0
				export _flag_force_new;;
		
			--help|-h 					)
				_flag_help=0
				export _flag_help;;
			--base*|-b* 					)
				if [[ -z "$(echo "$1" | grep '=')" ]]; then
					die "Missing argument for base method"
				else
					_base_method="${1#*=}"
					if [[ "${_base_method}" == '' ]]; then
						die "No target base. Aborting..."
					else							
						case "${_base_method}" in
							catalyst 	)
								_flag_base="catalyst"
								_e_report_back "Base: catalyst"
								export _flag_base;;
							precomp 	)
								_flag_base="precomp"
								_e_report_back "Base: precomp"
								export _flag_base;;
							*			)
								die "Wrong target base. Choose either catalyst or precomp"
						esac
					fi
				fi
				;;
			--keep|-k 					)
				_flag_keep=0
				_e_report_back "Keep old work is enabled"
				_e_report_back "Everything will be saved at /var/gse/work-date"
				export _flag_keep;;
	
			--health-check|-hc 			)
				_flag_health=0
				_e_report_back "Health check is enabled"
				export _flag_health;;
		
			--replace-new|-rpn 			)
				_flag_replace=0
				_e_report_back "Replacing base scripts..."
				export _flag_replace;;
		
			--no-kernel|-nk 			)
				_flag_kernel=1
				_e_report_back "Kernel and initramfs will be excluded"
				export _flag_kernel;;
		
			--no-initramfs|-ni 			)
				_flag_initrd=1
				_e_report_back "Initramfs will be excluded"
				export _flag_initrd;;
		
			--build-controller*|-bc*	)
				if [[ -z "$(echo "$1" | grep '=')" ]]; then
					die "Missing argument for controller's path"
				else
					_flag_controller_path="${1#*=}"
					[[ ${_flag_controller_path:0:1} != "/" ]] && _flag_controller_path="/${_flag_controller_path}"
					if [[ "${_flag_controller_path}" == '/' ]]; then
						die "Root is not allowed to be set as moddir path. Aborting..."
					else
						if [[ -d "${_flag_controller_path}" ]]; then
							_flag_controller=0
							export _flag_controller
							export _flag_controller_path
							_e_report_back "Controller flag enabled"
						else
							die "Error: moddir's target is not a directory"
						fi
					fi
				fi
				;;
		
			--build-minimal|-bm 		)
				_flag_minimal=0
				_e_report_back "Minimal build detected"
				_e_report_back "Custom packages will be excluded"
				_e_report_back "Custom profile will be excluded"
				_e_report_back "Custom flags will be excluded"
				_e_report_back "Kernel build will be excluded"
				_e_report_back "Initramfs will be excluded"
				export _flag_minimal;;
		
			--enforce*					)
				echo "$1"
				_export_args "$1" "enforce"
				_enforce_args=()
				for i in "${_on_eargs[@]}"; do
					_enforce_args+=("$i")
				done
				unset _on_eargs
				export _enforce_args
				_flag_enforce=0
				export _flag_enforce
				_e_report_back "The following enforcer arguments have been enabled"
				_e_report_back "${_enforce_args[@]}"
				;;
		
			--lawful-good*				)
				_export_args "$1" "lawful-good"
				_lawful_args=()
				for i in "${_on_eargs[@]}"; do
					_lawful_args+=("$i")
				done
				unset _on_eargs
				export _lawful_args
				_flag_lawful=0
				export _flag_lawful
				_e_report_back "The following lawful arguments have been enabled"
				_e_report_back "${_lawful_args[@]}"
				;;

			--verbose|-v 				)
				_e_report_back "Verbose flag is enabled"
				_flag_verbose=0
				export _flag_verbose;;

			--quiet|-q 					)
				_e_report_back "Silence flag is enabled"
				_flag_quiet=0
				export _flag_quiet;;
			-mm 						)
				_flag_mm=0
				export _flag_m;;
		
			--test						)
				_e_report_back "Test flag is enabled"
				_flag_test=0
				export _flag_test
				source "${CWORKDIR}/scripts/sinit" "$@" ;;

			*							)
				die "Unknown $1 operation"
				;;
		esac
		shift
	done
}

# CHECK GIVEN SPACE CONDITIONS
_free_space() {
	if [[ $(echo "$1" | sed 's/[^G]*//g') == "G" ]]; then
		if [[ "$(echo "$1" | sed 's/[^0-9]*//g')" -le "$2" ]]; then
			_e_report_back "$3 has less than $2G available space."
			_e_report_back "The average disk space $4"
			_e_report_back "Please resolve this issue with freeing at least $2G and start again"
			_e_report_back "When building the chaintool and bootstraping the system"
			die "Bailing out..."
		fi
	elif [[ $(echo "$1" | sed 's/[^M]*//g') == "M" ]]; then
		die "The storedir $1 has less than 1G of space. Aborting..."
	fi
}

# MAKE SOME CHECKS BEFORE INITIATING THE REST OF THE PROCESSES
witch_hunt() {
	inspector "$@"

	# CHECK IF CATALYST STOREDIR, PORTDIR AND DISTDIR ARE DIRECTORiES
	_export_catalyst_workdirs
	
	for i in "${CATDIR}" "${CATPORTDIR}" "${CATDISTDIR}"; do
		if [[ -e "$i" && ! -d "$i" ]]; then
			die "Error: $i is not a directory. Aborting"
		fi
	done

	# CHECK IF DIST.D EXISTS AND IS A DIRECTORY
	[[ -e "${CDISTDIR}" && ! -d "${CDISTDIR}" ]] && die "FATAL: dist.d is not a directory"

	# CHECK AVAILABLE SPACE OF STOREDIR AND DIST.D DIR
	_tmp_catdir=$(df -h "$CATDIR" | awk -F ' ' '{ print $4 }' | tail -n +2)
	_tmp_distdir=$(df -h "$CDISTDIR" | awk -F ' ' '{ print $4 }' | tail -n +2)

	_free_space "${_tmp_catdir}" "50" "Catalysts storedir" "catalyst will use for a stage3 tarball will be around 50G"
	_free_space "${_tmp_distdir}" "15" "Dist.d dir" "dist.d will use is at least 15G"
	unset CATDIR
	unset _tmp_distdir
	unset _tmp_catdir

	# CHECK FOR SUPERUSER PRIVILAGES
	if _am_i_root "$UID"; then
		_e_report_back "Superuser detected"
	else
		die "User is not superuser. Aborting"
	fi

	# PRIORITY CHECK FOR THE SCRIPT'S PID
	if [[ "$(ps -fl $$ | tail -n +2 | awk -F ' ' '{ print $8}')" -le 0 ]]; then
		_e_report_back "The priority of $0 is not high, and currently greater or equal to 0"
		_e_report_back "Changing priority to -5"
		renice -n -5 -p "$$" >/dev/null
	fi

	# ISSUE WARNING IF CONNECTION SEEMS TO BE FROM SSHD
	if [[ -n "${SSH_CLIENT}" || -n "${SSH_TTY}" ]]; then
		if [[ "$(echo "${TERM}")" == "screen" ]]; then
			_e_report_back "Session detected: ssh"
			_e_report_back "Tmux/Screen detected"
			_flag_tty="sshd"
			export _flag_tty
		else
			while true; do
				_e_report_back "================================================"
				_e_report_back "It appears you are running connected via ssh session"
				_e_report_back "It is recommended, if you haven't done yet, to stop this process"
				_e_report_back "and start it new from a tmux or screen session."
				_e_report_back "Most of the processes will require much time for normal computers, "
				_e_report_back "therefore it is a good idea to have a failsafe in case of a disconnect."
				_e_report_back "Do you wish to continue? {Not recommended}"
				_e_report_back "Answer Y/N "
				_e_report_back "================================================"
				read -rp "Input :: <= " YN
				case "$YN" in 
					[yY])
						_flag_tty="sshd"
						export _flag_tty
						break;;
					[nN])
						_e_report_back "Please restart from a detachable shell"
						die;;
				esac
			done
		fi
	fi

	# EXPORT NETWORK CONDITION
	_e_report_back "Scanning for networking..."
	if ping -c 3 www.gentoo.org >/dev/null 2>&1; then
		_e_report_back "Network detected"
		_flag_network=0
		export _flag_network
	else
		_e_report_back "Network not detected"
		_flag_network=1
		export _flag_network
	fi
	return 0
}

# INQUSITOR. CHECK FOR VERBOSITY LEVEL, CALL WITCH HUNT AND PROMPT IN CASE OF FORCE NEW
inquisitor() {
	inspector "$@"

	# ISSUE PARAMETER WARRNINGS
	parameters_check "$@"

	# PROMPT FOR FLAGS
	while true; do
		_e_report_back "================================================"
		_e_report_back "Do you wish to apply those and proceed?"
		_e_report_back "Answer: Y/N "
		read -rp "Input :: <= " YN
		case "$YN" in
			[yY])
				break;;
			[nN])
				die "Requested exit.";;
			*)
				_e_report_back "Please answer Y/N "
		esac
	done

	# PROMPT FOR CONTINUE IF FORCE_NEW IS PRESENT
	if [[ -n "$(echo ${_flag_force_new})" ]]; then
		_e_report_back "================================================"
		_e_report_back "================================================"
		_e_report_back "Warning: Force new flag has been enabled."
		_e_report_back "This flag will enable force globally."
		_e_report_back "Forced parts will always proceed to next part while purging everything that stands in the way"
		_e_report_back "See --enforce for forcing certain areas of the process, instead of this flag."
		_e_report_back "Are you sure? Y/N (Not recommended)"
		_e_report_back "================================================"
		_e_report_back "================================================"
		while true; do
			read -rp "Input :: <= " YN
			case "$YN" in
				[yN])
					break;;
				[nN])
					die "Requested exit."
					;;
				*	)
					_e_report_back "Please answer Y/N "
			esac
		done
	fi

	# MAKE CHECKS AS DESCRIBED IN WITCH HUNT
	witch_hunt "$@"

	if [[ "$(echo "${_flag_verbose}")" == 0 ]]; then
		_silence=1
		export _silence
	elif [[ "$(echo "${_flag_quiet}")" == 0 ]]; then
		_silence=0
		export _silence
	else
		_silence=9
		export _silence
	fi

	# PERFORM RUNTIME DEPENDENCIES CHECK. ISSUE WARNING FOR ALL BUT GENTOO
	if [[ "$(awk -F '=' '/RDEP/{ print $2 }' <"${CLOCALLG}/sinprog")" == 0 ]]; then
		_dependencies_check && sinit_flow_monitor "RDEP"
	fi

}

warp() {
	# DIE IF PP ARE NULL
	inspector "$@"

	# FILTER AND EXPORT ALL FLAGS AND ARGUMENTS. DIE UNLESS CONDITIONS ARE EXACT
	librarium "$@"

	# THIS FUNCTION WILL ISSUE ESSENTIAL SYSTEM CHECKS, BEFORE PROCEEDING.
	inquisitor "$@"

	_flags_list0=("$_flag_fetch" \
		"$_flag_force_new" \
		"$_flag_keep" \
		"$_flag_health" \
		"$_flag_replace" \
		"$_flag_keep" \
		"$_flag_initrd" \
		"$_flag_minimal" \
		"$_flag_controller" \
		"$_flag_controller_path" \
		"$_flag_enforce" \
		"$_enforce_args" \
		"$_flag_lawful" \
		"$_lawful_args" \
		"$_flag_verbose" \
		"$_flag_quiet" \
		"$_flag_test"
		"$_flag_network")
	# STAGE A

	# THIS LIST WILL BE EXPORTED TO THE SOURCED SINIT BUILDER SCRIPT
	if [[ -n "${_flag_base}" ]]; then
		_flags_stagea=()

		_flags_listA=("_flag_fetch" \
			"_flag_force_new" \
			"_flag_keep" \
			"_flag_minimal" \
			"_flag_enforce" \
			"_enforce_args" \
			"_flag_lawful" \
			"_lawful_args" \
			"_flag_verbose" \
			"_flag_quiet" \
			"_flag_test" \
			"_flag_network" \
			"_flag_base")

		for i in "${_flags_listA[@]}"; do
			if [[ "$(echo ${!i})" == 0 ]]; then
				_flags_stagea+=("${i}")
			fi
		done

		source "${CWORKDIR}/scripts/sinit" "${_flags_stagea[@]}"
	else
		_fetch_new "fetch_new"
	fi
	# STAGE B

	# STAGE C

}


